/** @license 2019 Neil Edelman, distributed under the terms of the
 [MIT License](https://opensource.org/licenses/MIT). */

#include <stdio.h>  /* printf sprintf */
#include <string.h> /* memset strchr */
#include <stdlib.h> /* malloc free */
/* #define NDEBUG */
#include <assert.h> /* assert */
#include <errno.h>  /* errno EILSEQ */
#include "../src/Symbol.h"
#include "../src/Cdoc.h"
#include "../src/Scanner.h" /** \include */


/* Define {CharArray}, a vector of characters -- dynamic string in which we
 will store the input. */
#define ARRAY_NAME Char
#define ARRAY_TYPE char
#include "../src/Array.h"


/* This defines `ScanState`; the trailing comma on an `enum` is not proper
 `C90`, hopefully they will fix it. */
/*!types:re2c*/


/** Scanner reads a file and extracts semantic information. */
struct Scanner {
	/* `re2c` variables; these point directly into `buffer`. */
	const char *marker, *ctx_marker, *from, *cursor;
	/* Weird `c2re` stuff: these fields have to come after when >5? */
	const char *sub0, *sub1;
	struct CharArray buffer;
	enum ScanState state;
	enum Symbol symbol;
	int indent_level;
	int ignore_block;
	size_t line, doc_line;
	const char *fn;
};

static struct Scanner *cur;

/** Prints line info in a static buffer, (to be printed?) */
static const char *pos(void) {
	static char p[128];
	if(!cur) {
		sprintf(p, "No file loaded");
	} else {
		const int max_size = 32,
			is_truncated = (cur->from + max_size < cur->cursor) ? 1 : 0,
			len = is_truncated ? max_size :
			(int)(cur->cursor - cur->from);
		assert(cur->from <= cur->cursor);
		sprintf(p, "%.32s:%lu, %s \"%.*s\" state %d", cur->fn,
			(unsigned long)cur->line, symbols[cur->symbol], len,
			cur->from, cur->state);
	}
	return p;
}

/*!stags:re2c format = 'const char *@@;'; */

/*!re2c
re2c:yyfill:enable   = 0;
re2c:define:YYCTYPE  = char;
re2c:define:YYCURSOR = cur->cursor;
re2c:define:YYMARKER = cur->marker; // Rules overlap.
re2c:define:YYCTXMARKER = cur->ctx_marker;
re2c:define:YYCONDTYPE = "ScanState";
re2c:define:YYGETCONDITION = "cur->state";
re2c:define:YYGETCONDITION:naked = 1;
re2c:define:YYSETCONDITION = "cur->state = @@;";
re2c:define:YYSETCONDITION:naked = 1;
re2c:flags:tags      = 1;

// Eof is marked by null when preparing files for lexing.
eof = "\x00";
whitespace = [ \t\v\f];
newline = "\n" | "\r" "\n"?;

nbthinsp = "\\,";
mathcalo = "\\O";
ctheta = "\\Theta";
comega = "\\Omega";
times = "\\times";
cdot = "\\cdot";
escapes = nbthinsp | mathcalo | ctheta | comega | times | cdot;

// Words can be composed of anything except:
// " \t\n\v\f\r" whitespace and newline;
// "*" potential end-of-comment;
// "`" or "_" math/em;
// "~" non-breaking space;
// "!" image start;
// "\\" escape;
// "@" for each-block-tag;
// "<>[]" for embedded things;
// "\x00" eof.
// Words in math/code, em, and inside brackets do not nest.
word_base = [^ \t\n\r\v\f*_`~!\\@<>[\]\x00];
escape_asterisk = "*";
escape_lone = "_" | "`" | "~";
escape_multi = "!" | "\\" | "@" | "<" | ">";
escape_brackets = "[" | "]";
escape_except_asterisk = escape_multi | escape_lone | escape_brackets;
escape_inside = escape_asterisk | escape_multi | escape_lone;
escape_outside = escape_asterisk | escape_multi | escape_brackets;
word        = word_base+ | escape_outside;
word_math   = (word_base | [_@<>[\]] )+ | escape_outside;
word_em     = (word_base | [`@<>[\]] )+ | escape_outside;
word_inside = (word_base | [_`@<>] )+ | escape_inside;
begin_doc = "/""*""*"+;
end_doc = "*"+"/";
art = whitespace* "*"? newline " *";
white_inside = whitespace | newline | art [^/[\]\x00];
all_inside = word_inside | "\\" escape_except_asterisk | white_inside
	| "\\*" [^/[\]\x00] | escapes;
qfile = [^"\t\n\r\v\f]+;
include_comment = whitespace*
	"/*""*"+ whitespace* "@include" whitespace* "*"+"/";
comment_break = "/" "*"+ "*" "/";
begin_comment = "/""*";
end_comment = "*""/";
cxx_comment = "//" [^\n\x00]*;
macro_start = "#" | "%:";
// fixme: No trigraph support.
// char_type = "u8"|"u"|"U"|"L"; <- These get caught in id; don't care.
oct = "0" [0-7]*;
dec = [1-9][0-9]*;
hex = '0x' [0-9a-fA-F]+;
frc = [0-9]* "." [0-9]+ | [0-9]+ ".";
exp = 'e' [+-]? [0-9]+;
flt = (frc exp? | [0-9]+ exp) [fFlL]?;
number = (oct | dec | hex | flt) [uUlL]*;
operator = ":" | "::" | "?" | "+" | "-" | "*" | "/" | "%" | "^"
	| "xor" | "&" | "bitand" | "|" | "bitor" | "~" | "compl" | "!" | "not"
	| "<" | ">" | "==" | "+=" | "-=" | "%=" | "^=" | "xor_eq"
	| "&=" | "and_eq" | "|=" | "or_eq" | "<<" | ">>" | ">>=" | "<<="
	| "!=" | "not_eq" | "<=" | ">=" | "&&" | "and" | "||" | "or" | "++"
	| "--" | "." | "->";
assignment = "=";
// Extension (hack) for generic macros; if one names them this way, it will
// be documented nicely; the down side is, these are legal names for
// identifiers; will be confused if you name anything this way that IS an
// identifier. Don't do that.
generic = [A-Z]+ "_";
// Supports only C90 ids. That would be complicated. I suppose you could hack
// it to accept a super-set?
id = [a-zA-Z_][a-zA-Z_0-9]*;
generic_id = (("<" [A-Z]+ ">")? id)+;
// <https://tools.ietf.org/html/rfc3986#appendix-B> and also
// " \t\n\v\f\r*<>()&\x00" disallowed because then it crashes / escapes comment
// / links [](). ("The special characters "$-_.+!*'()," and
// reserved characters used for their reserved purposes may be used unencoded
// within a URL," RFC 1738, so () is completly braindead.)
// '<' 3C, '>' 3E, '#' 23, '(' %28, ')' %29, '*' %2A, ' ' %20
uri_scheme = [^:/?# \t\n\v\f\r*<>()&\x00]+ ":";
uri_authority = "//" [^/?# \t\n\v\f\r*<>()&\x00]*;
uri_path = [^?# \t\n\v\f\r*<>()&\x00]+;
// It has to have a * or / in it or else it's just a word, which might be a
// uri, but mmm, really?
looks_like_uri_path = ("."{1,2} "/")* (
	  ([^?# \t\n\v\f\r*<>()&./\x00]* ("/" | ".") [^?# \t\n\v\f\r*<>()&./\x00]+)
	| ([^?# \t\n\v\f\r*<>()&./\x00]+ ("/" | ".") [^?# \t\n\v\f\r*<>()&./\x00]*)
)+;
uri_query = ("?" [^# \t\n\v\f\r*<>()&\x00]*);
uri_fragment = ("#" [^ \t\n\v\f\r*<>()&\x00]*);
absolute_uri = uri_scheme uri_authority uri_path uri_query? uri_fragment?;
relative_uri = uri_scheme? uri_authority?
	looks_like_uri_path uri_query? uri_fragment?;
uri = absolute_uri | relative_uri;
// Citation format. Not authoritative.
// Author is equivalent to <[A-Z][A-Za-z'`-]+>, except accepting all code
// points after ASCII. It supports accents, but includes stuff that it shoudn't.
author = [^\x00-\x40\x5B-\x7F][^\x00-\x26\x28-\x2C\x2E-\x40\x5B-\x5F\x7b-\x7f]+;
etalia = "et" whitespace? "al" "."?;
authorsep = ","? (whitespace? "and" whitespace | whitespace? "&" whitespace?
	| whitespace?);
closing = ","? whitespace?;
date = [1-3][0-9][0-9][0-9];
page = ","? whitespace? (("pp" | "p") "."?)? whitespace?
	[0-9]+ (whitespace? "-"{1,2} whitespace? [0-9]+)?;
citation = author (authorsep author)* (closing etalia)? closing date page?;
// Lists.
list = " \\* ";
*/

/** Scans. */
static enum Symbol scan(void) {
	const char *sub0, *sub1;
	assert(cur);
	cur->sub0 = cur->sub1 = 0;
	cur->doc_line = cur->line;
reset:
	cur->from = cur->cursor;
scan:
/*!re2c
	// Oops, don't know how to deal with that.
	<*> * { return fprintf(stderr, "%s: unexpected state.\n", pos()),
		errno = EILSEQ, END; }
	<comment, macro_comment, string, character> * { goto scan; }
	// Everything stops at EOF.
	<*> "\x00" {
		if(cur->state != yyccode || cur->indent_level)
			fprintf(stderr, "%s: unexpected EOF.\n", pos()),
			errno = EILSEQ;
		return END;
	}
	// Return space.
	<doc, em, math> whitespace+ { return SPACE; }
	<code, include> whitespace+ { goto reset; }
	// Newlines are generally ignored but documentation counts for paragraphs.
	<*> newline {
		cur->line++;
		if(cur->state == yycdoc || cur->state == yycanchor)
			return NEWLINE;
		else if(cur->state == yycstring || cur->state == yyccharacter)
			return fprintf(stderr, "%s: string syntax.\n", pos()),
			errno = EILSEQ, END;
		else if(cur->state == yycmacro) cur->state = yyccode;
		goto reset;
	}

	// Continuation.
	<string, character, macro, include> "\\" newline
		{ cur->line++; goto scan; }
	<string> "\"" { cur->state = yyccode; return CONSTANT; }
	<character> "'" { cur->state = yyccode; return CONSTANT; }
	<string, character> "\\". { goto scan; }
	<comment> end_comment :=> code
	<macro_comment> end_comment :=> macro
	// C++ comments we aren't concerned with.
	<code, macro> cxx_comment { goto reset; }
	// With flattening the `ScanState` stack, this is not actually worth
	// the effort; honestly, it's not going to matter.
	<macro> begin_doc / [^/] { return fprintf(stderr,
		"%s: documentation inside macro.\n", pos()), errno = EILSEQ,
		END; }
	// Everything is ignored except comments.
	<macro> ([^\x00\n\r] \ [/])+  { goto scan; }
	<macro> [/] / [^*]  { goto scan; }
	<macro> begin_comment :=> macro_comment
	<code> comment_break { goto reset; } // Like this: /*****/.
	<code> begin_comment :=> comment
	<code> "#include" whitespace+ "\"" @sub0 qfile @sub1 "\"" whitespace* begin_doc whitespace* "\\include" whitespace* end_doc
		{ cur->sub0 = sub0, cur->sub1 = sub1;
		return cur->state = yycmacro, LOCAL_INCLUDE; }
	<code> macro_start :=> macro
	<code> "L"? "\"" :=> string
	<code> "'" :=> character
	<code> number       { return CONSTANT; }
	<code> operator     { return OPERATOR; }
	<code> assignment   { return ASSIGNMENT; }
	<code> generic      { return ID_ONE_GENERIC; }
	<code> generic generic { return ID_TWO_GENERICS; }
	<code> generic generic generic { return ID_THREE_GENERICS; }
	<code> "struct"     { return STRUCT; }
	<code> "union"      { return UNION; }
	<code> "enum"       { return ENUM; }
	<code> "typedef"    { return TYPEDEF; }
	<code> "static"     { return STATIC; }
	<code> "void"       { return VOID; }
	<code> ("{" | "<%") { cur->indent_level++; return LBRACE; }
	<code> ("}" | "%>") { cur->indent_level--; return RBRACE; }
	<code> ("[" | "<:") { return LBRACK; }
	<code> ("]" | ":>") { return RBRACK; }
	<code> "("          { return LPAREN; }
	<code> ")"          { return RPAREN; }
	<code> ","          { return COMMA; }
	<code> ";"          { return SEMI; }
	<code> "..."        { return ELLIPSIS; }
	<code> id           { return ID; }

	<code> begin_doc / [^/] { return cur->state = yycdoc, DOC_BEGIN; }
	// Also newlines in comments should be optionally ascii-art.
	<doc, math, em, param_item, param_more> art / [^/] {
		cur->line++;
		if(cur->state == yycdoc) return NEWLINE;
		goto reset;
	}
	<doc, math, em, param_item, param_more, anchor> "\\*""/" { return
		fprintf(stderr, "%s: escape past end of documentation.\n",
		pos()), errno = EILSEQ, END; }
	<math, em, param_item, param_more, anchor, pre> end_doc { return
		fprintf(stderr, "%s: unexpected end of documentation.\n",
		pos()), errno = EILSEQ, END; }
	<doc> end_doc { return cur->state = yyccode, DOC_END; }

	<doc>  word      { return WORD; }
	<math> word_math { return WORD; }
	<em>   word_em   { return WORD; }
	<doc, math, em, anchor> "\\" escape_except_asterisk { return ESCAPE; }
	<doc, math, em, anchor> "\\*" / [^/] { return ESCAPE; }
	<doc, math, em, anchor> nbthinsp { return NBTHINSP; }
	<doc, math, em, anchor> mathcalo { return MATHCALO; }
	<doc, math, em, anchor> ctheta   { return CTHETA; }
	<doc, math, em, anchor> comega   { return COMEGA; }
	<doc, math, em, anchor> times    { return TIMES; }
	<doc, math, em, anchor> cdot     { return CDOT; }
	<doc> "_" { return cur->state = yycem, EM_BEGIN; }
	<em> "_" { return cur->state = yycdoc, EM_END; }
	<doc> "`" { return cur->state = yycmath, MATH_BEGIN; }
	<math> "`" { return cur->state = yycdoc, MATH_END; }
	<doc> "~" { return NBSP; }
	<doc> list { return LIST_ITEM; }
	<doc> "\\\"" " "? / [^\n\r\x00] { cur->state = yycpre; goto reset; }
	<doc> "\\\"" " "? [\n\r\x00] { return
		fprintf(stderr, "%s: preformatted cannot be empty.\n", pos()),
		errno = EILSEQ, END; }
	<pre> [^*\n\r\x00]+ | "*"+ / [\n\r\x00]
		{ return cur->state = yycdoc, PREFORMATTED; }
	<pre> [^*\n\r\x00]+ / "*" { goto scan; }
	<pre> "*"+ / [^/\n\r\x00] { goto scan; }

	// These are recognised in the documentation as stuff; parse them further
	// using `sub`.
	<doc> "<" @sub0 uri @sub1 ">"
		{ cur->sub0 = sub0, cur->sub1 = sub1; return URL; }
	<doc> "<" @sub0 citation @sub1 ">"
		{ cur->sub0 = sub0, cur->sub1 = sub1; return CITE; }
	<doc> "<fn:" @sub0 generic_id @sub1 ">"
		{ cur->sub0 = sub0, cur->sub1 = sub1; return SEE_FN; }
	<doc> "<tag:" @sub0 generic_id @sub1 ">"
		{ cur->sub0 = sub0, cur->sub1 = sub1; return SEE_TAG; }
	<doc> "<typedef:" @sub0 generic_id @sub1 ">"
		{ cur->sub0 = sub0, cur->sub1 = sub1; return SEE_TYPEDEF;}
	<doc> "<data:" @sub0 generic_id @sub1 ">"
		{ cur->sub0 = sub0, cur->sub1 = sub1; return SEE_DATA; }
	<doc> "[" whitespace* / all_inside* "](" uri ")"
		{ return cur->state = yycanchor, LINK_START; }
	<doc> "![" whitespace* / all_inside* "](" uri ")"
		{ return cur->state = yycanchor, IMAGE_START; }

	// These are tags.
	<doc> "@title"      { return ATT_TITLE; }
	<doc> "@param"      { return cur->state = yycparam_begin, ATT_PARAM; }
	<doc> "@author"     { return ATT_AUTHOR; }
	<doc> "@std"        { return ATT_STD; }
	<doc> "@depend"     { return ATT_DEPEND; }
	<doc> "@fixme"      { return ATT_FIXME; }
	<doc> "@return"     { return ATT_RETURN; }
	<doc> "@throws"     { return cur->state = yycparam_begin, ATT_THROWS; }
	<doc> "@implements" { return ATT_IMPLEMENTS; }
	<doc> "@order"      { return ATT_ORDER; }
	<doc> "@allow"      { return ATT_ALLOW; }
	<doc> "@license"    { return ATT_LICENSE; }
	// fixme: have date_begin @since[], @updated[], maybe updated is bad.
	// Why not just have it updated now?
	// Check if now is in the future.

	// Parameter lists.
	<param_begin> "[" { return cur->state = yycparam_item, DOC_LEFT; }
	<param_item>  id  { return cur->state = yycparam_more, DOC_ID; }
	<param_more>  "," { return cur->state = yycparam_item, DOC_COMMA; }
	<param_more>  "]" { return cur->state = yycdoc,        DOC_RIGHT; }
	<param_item, param_more> whitespace+ { goto reset; }
	<param_begin, param_item, param_more> * {
		return fprintf(stderr, "%s: not allowed in parameter list.\n",
		pos()), errno = EILSEQ, END; }

	// Link/image text. Ended by `URL`. MD []() is inconsistent notation. :[
	<anchor>  word_inside { return WORD; }
	<anchor>  whitespace+ { return SPACE; }
	<anchor>  whitespace* "](" @sub0 uri @sub1 ")"
		{ cur->sub0 = sub0, cur->sub1 = sub1;
		return cur->state = yycdoc, URL; }
*/
}

static void zero_scanner(struct Scanner *const scanner) {
	assert(scanner);
	scanner->marker = scanner->ctx_marker = scanner->from = scanner->cursor = 0;
	scanner->sub0 = scanner->sub1 = 0;
	CharArray(&scanner->buffer);
	scanner->state = yyccode; /* Generated by `re2c`. */
	scanner->symbol = END;
	scanner->indent_level = 0;
	scanner->ignore_block = 0;
	scanner->line = scanner->doc_line = 0;
	scanner->fn = 0;
}

/** Unloads scanner from memory. */
void Scanner_(struct Scanner *const scanner) {
	if(!scanner) return;
	CharArray_(&scanner->buffer);
	zero_scanner(scanner);
}

/** Tries to open `fn` and read it all into memory.
 @param[notify] The function that is notified when it gets a match. It
 interpets return of false for error.
 @return Success.
 @throws[malloc, fopen, fread]
 @throws[EILSEQ] File has embedded nulls.
 @throws[EDOM] Passed null. */
struct Scanner *Scanner(const char *const fn, int (*const notify)(void)) {
	FILE *fp = 0;
	const size_t granularity = 1024;
	char *read_here, *zero;
	size_t nread, zero_len;
	struct Scanner *scanner = 0, *previous;
	if(!notify || !fn) { errno = EDOM; goto catch; }
	if(!(scanner = malloc(sizeof *scanner))) goto catch;
	zero_scanner(scanner);
	scanner->fn = fn;
	if(!(fp = fopen(fn, "r"))) goto catch;
	/* Read all contents at once. */
	do {
		if(!(read_here = CharArrayBuffer(&scanner->buffer, granularity))
			|| (nread = fread(read_here, 1, granularity, fp), ferror(fp))
			|| !CharArrayExpand(&scanner->buffer, nread)) goto catch;
	} while(nread == granularity);
	fclose(fp), fp = 0;
	/* Embed '\0' on the end for simple lexing. */
	if(!(zero = CharArrayNew(&scanner->buffer))) goto catch;
	*zero = '\0';
	/* Point these toward the first char; `buffer` is necessarily done
	 growing, or we could not do this. */
	scanner->marker = scanner->ctx_marker = scanner->from = scanner->cursor
		= CharArrayGet(&scanner->buffer);
	scanner->line = scanner->doc_line = 1;
	/* We use simplified sentinel method of detecting EOF, so the file can have
	 no embedded '\0'. */
	{
		const char *const buffer = CharArrayGet(&scanner->buffer);
		zero_len = (size_t)(strchr(buffer, '\0') - buffer);
		if(zero_len != CharArraySize(&scanner->buffer) - 1)
			{ errno = EILSEQ; fprintf(stderr,
			"Expects Modified UTF-8 encoding; embedded '\\0' at byte %lu/%lu."
			"\n", (unsigned long)zero_len,
			(unsigned long)CharArraySize(&scanner->buffer) - 1); goto catch; }
	}
	/* Scans all. */
	errno = 0;
	previous = cur, cur = scanner;
	while((scanner->symbol = scan()) && notify())
		if(CdocOptionsDebug()) fprintf(stderr, "%s.\n", pos());
	cur = previous;
	if(errno) goto catch;
	goto finally;
catch:
	Scanner_(scanner), scanner = 0;
finally:
	if(fp) fclose(fp);
	return scanner;
}

enum Symbol ScannerSymbol(void) {
	if(!cur) return END;
	return cur->symbol;
}

/** @throws[EDOM] When the scanner hasn't been called or the no scanner.
 @throws[malloc] Couldn't get memory. */
const char *ScannerFrom(void) {
	if(!cur) { errno = EDOM; return 0; }
	if(cur->sub0) return assert(cur->sub0 < cur->sub1), cur->sub0;
	else if(cur->from) return assert(cur->from < cur->cursor), cur->from;
	errno = EDOM;
	return 0;
}
const char *ScannerTo(void) {
	if(!cur) { errno = EDOM; return 0; }
	if(cur->sub1) return cur->sub1;
	else if(cur->cursor) return cur->cursor;
	errno = EDOM;
	return 0;
}
const char *ScannerFilename(void) { return cur ? cur->fn : "nofile"; }
size_t ScannerLine(void) { return cur ? cur->line : 0; }
int ScannerIndentLevel(void) { return cur ? cur->indent_level : 0; }
