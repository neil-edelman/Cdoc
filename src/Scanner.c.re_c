/** 2019 Neil Edelman, distributed under the terms of the
 [MIT License](https://opensource.org/licenses/MIT). */

#include <stdio.h>  /* printf sprintf */
#include <string.h> /* memset strchr */
/* #define NDEBUG */
#include <assert.h> /* assert */
#include <errno.h>  /* errno EILSEQ */
#include "../src/Symbol.h"
#include "../src/Report.h"
#include "../src/Scanner.h"


/* Define {CharArray}, a vector of characters -- dynamic string. */
#define ARRAY_NAME Char
#define ARRAY_TYPE char
#include "../src/Array.h"


/* This defines `ScanState`; the trailing comma on an `enum` is not proper
 `C90`, hopefully they will fix it. */
/*!types:re2c*/


/** Scanner reads a file and extracts semantic information. */
struct Scanner {
	/* `re2c` variables; these point directly into `buffer`. */
	const char *marker, *ctx_marker, *from, *cursor;
	/* Weird `c2re` stuff: these fields have to come after when >5? */
	struct CharArray buffer;
	enum ScanState state;
	enum Symbol symbol;
	int indent_level;
	int ignore_block;
	size_t line, doc_line;
} scanner;

/** Prints line info in a static buffer, (to be printed?) */
static const char *pos(void) {
	static char p[128];
	const int max_size = 32,
		is_truncated = (scanner.from + max_size < scanner.cursor) ? 1 : 0,
		len = is_truncated ? max_size : (int)(scanner.cursor - scanner.from);
	assert(scanner.from <= scanner.cursor);
	sprintf(p, "line %lu, indent %d, %s: \"%.*s\"",
		(unsigned long)scanner.line, scanner.indent_level,
		symbols[scanner.symbol], len, scanner.from);
	return p;
}

/*!re2c
re2c:yyfill:enable   = 0;
re2c:define:YYCTYPE  = char;
re2c:define:YYCURSOR = scanner.cursor;
re2c:define:YYMARKER = scanner.marker; // Rules overlap.
re2c:define:YYCTXMARKER = scanner.ctx_marker;
re2c:define:YYCONDTYPE = "ScanState";
re2c:define:YYGETCONDITION = "scanner.state";
re2c:define:YYGETCONDITION:naked = 1;
re2c:define:YYSETCONDITION = "scanner.state = @@;";
re2c:define:YYSETCONDITION:naked = 1;

// Eof is marked by null when preparing files for lexing.
eof = "\x00";
whitespace = [ \t\v\f];
newline = "\n" | "\r" "\n"?;

// Words can be composed of anything except:
// " \t\n\v\f\r" whitespace and newline;
// "~" non-breaking space;
// "*" potential end-of-comment;
// "\\" escape;
// "`" or "_" (at the beginning or end) for em;
// "@" (at the beginning) for each-block-tag;
// "<>[]" for embedded things;
// "\x00" eof.
word_base = [^ \t\n\v\f\r~*\\`_@<>\[\]\x00];
word_begin = word_base | ">" | "]";
word_in    = word_begin | "@" | "<" | ">" | "[" | "]";
word_end   = word_begin | "@" | "<" | "[";
word = word_base | (word_begin word_in* word_end)
	| "*" | "@" | "<" | ">" | "[" | "]";
begin_doc = "/""*"+;
end_doc = "*"+"/";
art = whitespace* "*"? newline " *";
comment_break = "/" "*"+ "*" "/";
begin_comment = "/""*";
end_comment = "*""/";
cxx_comment = "//" [^\n\x00]*;
macro = ("#" | "%:");
// fixme: No trigraph support.
// char_type = "u8"|"u"|"U"|"L"; <- These get caught in id; don't care.
oct = "0" [0-7]*;
dec = [1-9][0-9]*;
hex = '0x' [0-9a-fA-F]+;
frc = [0-9]* "." [0-9]+ | [0-9]+ ".";
exp = 'e' [+-]? [0-9]+;
flt = (frc exp? | [0-9]+ exp) [fFlL]?;
number = (oct | dec | hex | flt) [uUlL]*;
operator = ":" | "..." | "::" | "?" | "+" | "-" | "*" | "/" | "%" | "^"
	| "xor" | "&" | "bitand" | "|" | "bitor" | "~" | "compl" | "!" | "not"
	| "<" | ">" | "==" | "+=" | "-=" | "%=" | "^=" | "xor_eq"
	| "&=" | "and_eq" | "|=" | "or_eq" | "<<" | ">>" | ">>=" | "<<="
	| "!=" | "not_eq" | "<=" | ">=" | "&&" | "and" | "||" | "or" | "++"
	| "--" | "." | "->";
assignment = "=";
// Extension (hack) for generic macros; if one names them this way, it will
// be documented nicely; the down side is, these are legal names for
// identifiers; will be confused if you name anything this way that IS an
// identifier. Don't do that.
generic = [A-Z]+ "_";
// Supports only C90 ids. That would be complicated. I suppose you could hack
// it to accept a super-set?
id = [a-zA-Z_][a-zA-Z_0-9]*;
generic_id = (("<" [A-Z]+ ">")? id)+;
// <https://tools.ietf.org/html/rfc3986#appendix-B> and also
// " \t\n\v\f\r*<>&\x00" disallowed because then it crashes / escapes comment.
uri_scheme = ([^:/?# \t\n\v\f\r*<>&\x00]+ ":");
uri_authority = ("//" [^/?# \t\n\v\f\r*<>&\x00]*);
uri_path = [^?# \t\n\v\f\r*<>&\x00]*;
uri_query = ("?" [^# \t\n\v\f\r*<>&\x00]*);
uri_fragment = ("#" [^ \t\n\v\f\r*<>&\x00]*);
absolute_uri = uri_scheme uri_authority uri_path uri_query? uri_fragment?;
relative_uri = uri_scheme? uri_authority? uri_path uri_query? uri_fragment?;
// Citation format. Not authoritative.
author = [A-Z][A-Za-z'`-]+; // Fixme: No!!! UTF-8
etalia = "et" whitespace+ "al" "."?;
authorsep = ","? whitespace* ("and" | "&" | whitespace) whitespace*;
closing = ","? whitespace*;
date = [1-3][0-9][0-9][0-9];
page = ","? whitespace* (("pp" | "p") "."?)? whitespace*
	[0-9]+ (whitespace* "-"{1,2} whitespace* [0-9]+)?;
citation = whitespace* author (authorsep author)*
	(closing etalia)? closing date page? whitespace*;
// Lists.
list = " -* ";
// Math/code blocks. Added after; very meh.
preformated = "\t" [^*\n\x00]*;
*/

/** Scans. */
static enum Symbol scan(void) {
	scanner.doc_line = scanner.line;
reset:
	scanner.from = scanner.cursor;
scan:
/*!re2c
	// Oops, don't know how to deal with that.
	<*> * { return fprintf(stderr, "Unknown;\n%s.\n", pos()),
		errno = EILSEQ, END; }
	// Everything stops at EOF.
	<*> "\x00" {
		if(scanner.state != yyccode || scanner.indent_level)
			fprintf(stderr, "Unexpected EOF;\n%s.\n", pos()), errno = EILSEQ;
		return END;
	}
	// Ignore whitespace everywhere.
	<*> whitespace+ { if(scanner.state == yycdoc) return SPACE; goto reset; }
	// Newlines are generally ignored but documentation counts for paragraphs.
	<*> newline {
		scanner.line++;
		if(scanner.state == yycdoc) return NEWLINE;
		else if(scanner.state == yycstring || scanner.state == yyccharacter)
			return fprintf(stderr, "String syntax;\n%s.\n", pos()),
			errno = EILSEQ, END;
		else if(scanner.state == yycmacro) scanner.state = yyccode;
		goto reset;
	}

	// Continuation.
	<string, character, macro> "\\" newline { scanner.line++; goto scan; }
	<string> "\"" { scanner.state = yyccode; return CONSTANT; }
	<character> "'" { scanner.state = yyccode; return CONSTANT; }
	<string, character> "\\". { goto scan; }
	<comment> end_comment :=> code
	<macro_comment> end_comment :=> macro
	// C++ comments we aren't concerned with.
	<code, macro> cxx_comment { goto reset; }
	// With flattening the `ScanState` stack, this is not actually worth
	// the effort; honestly, it's not going to matter.
	<macro> begin_doc / [^/] { return fprintf(stderr,
		"Documentation inside macro;\n%s.\n", pos()), errno = EILSEQ, END; }
	<code> comment_break { goto reset; } // Like this: /*****/.
	<code> begin_comment :=> comment
	<macro> begin_comment :=> macro_comment
	<code> macro :=> macro
	<code> "L"? "\"" :=> string
	<code> "'" :=> character
	<code> number       { return CONSTANT; }
	<code> operator     { return OPERATOR; }
	<code> assignment   { return ASSIGNMENT; }
	<code> generic      { return ID_ONE_GENERIC; }
	<code> generic generic { return ID_TWO_GENERICS; }
	<code> generic generic generic { return ID_THREE_GENERICS; }
	<code> "struct"     { return STRUCT; }
	<code> "union"      { return UNION; }
	<code> "enum"       { return ENUM; }
	<code> "typedef"    { return TYPEDEF; }
	<code> "static"     { return STATIC; }
	<code> "void"       { return VOID; }
	<code> ("{" | "<%") { scanner.indent_level++; return LBRACE; }
	<code> ("}" | "%>") { scanner.indent_level--; return RBRACE; }
	<code> ("[" | "<:") { return LBRACK; }
	<code> ("]" | ":>") { return RBRACK; }
	<code> "("          { return LPAREN; }
	<code> ")"          { return RPAREN; }
	<code> ","          { return COMMA; }
	<code> ";"          { return SEMI; }
	<code> "..."        { return ELLIPSES; }
	<code> id           { return ID; }

	<code> begin_doc / [^/] { return scanner.state = yycdoc, DOC_BEGIN; }
	// Also newlines in comments should be optionally ascii-art.
	<doc, math, em, param_item, param_more> art / [^/] {
		scanner.line++;
		if(scanner.state == yycdoc) return NEWLINE;
		goto reset;
	}
	<doc, math, em, param_item, param_more> "\\*""/" { return
		fprintf(stderr, "Escape past end of documentation;\n%s.\n", pos()),
		errno = EILSEQ, END; }
	<math, em, param_item, param_more> end_doc { return
		fprintf(stderr, "Unexpected end of documentation;\n%s.\n", pos()),
		errno = EILSEQ, END; }
	<doc> end_doc { return scanner.state = yyccode, DOC_END; }

	<doc, math, em> word { return WORD; }
	<doc, math, em> "\\"[^*,\x00] { return ESCAPE; }
	<doc, math, em> "\\," { return NBTHINSP; }
	<doc, math, em> "\\*" / [^/] { return ESCAPE; }
	<doc, math, em> "\\\x00" { return fprintf(stderr,
		"Escape past EOF;\n%s.\n", pos()), errno = EILSEQ, END; }
	<doc> "_" { return scanner.state = yycem, EM_BEGIN; }
	<em> "_" { return scanner.state = yycdoc, EM_END; }
	<doc> "`" { return scanner.state = yycmath, MATH_BEGIN; }
	<math> "`" { return scanner.state = yycdoc, MATH_END; }

	// These are recognised in the documentation as stuff. fixme: s-tags.
	<doc> "<" absolute_uri ">" { return URL; }
	<doc> "<" citation ">" { return CITE; }
	<doc> "<fn:" generic_id ">" { return SEE_FN; }
	<doc> "<tag:" generic_id ">" { return SEE_TAG; }
	<doc> "<typedef:" generic_id ">" { return SEE_TYPEDEF; }
	<doc> "<data:" generic_id ">" { return SEE_DATA; }
	<doc> "[" whitespace* (word whitespace*)+ "](" absolute_uri ")"
		{ return LINK; }
	<doc> "![" whitespace* (word whitespace*)+ "](" relative_uri ")"
		{ return IMAGE; }
	<doc> "~" { return NBSP; }
	<doc> list { return LIST_ITEM; }
	<doc> preformated { return PREFORMATED; }

	// These are tags.
	<doc> "@title"      { return ATT_TITLE; }
	<doc> "@param"      { return scanner.state = yycparam_begin, ATT_PARAM; }
	<doc> "@author"     { return ATT_AUTHOR; }
	<doc> "@std"        { return ATT_STD; }
	<doc> "@depend"     { return ATT_DEPEND; }
	<doc> "@version"    { return ATT_VERSION; }
	<doc> "@fixme"      { return ATT_FIXME; }
	<doc> "@return"     { return ATT_RETURN; }
	<doc> "@throws"     { return scanner.state = yycparam_begin, ATT_THROWS; }
	<doc> "@implements" { return ATT_IMPLEMENTS; }
	<doc> "@order"      { return ATT_ORDER; }
	<doc> "@allow"      { return ATT_ALLOW; }

	// Parameter lists.
	<param_begin> "[" { return scanner.state = yycparam_item, DOC_LEFT; }
	<param_item>  id  { return scanner.state = yycparam_more, DOC_ID; }
	<param_more>  "," { return scanner.state = yycparam_item, DOC_COMMA; }
	<param_more>  "]" { return scanner.state = yycdoc,        DOC_RIGHT; }
	<param_begin, param_item, param_more> * {
		return fprintf(stderr, "Unrecognised in parameter list;\n%s.\n", pos()),
		errno = EILSEQ, END; }
*/
}

/** Unloads scanner from memory. */
void Scanner_(void) {
	scanner.marker = scanner.ctx_marker = scanner.from = scanner.cursor = 0;
	CharArray_(&scanner.buffer);
	scanner.state = yyccode; /* Generated by `re2c`. */
	scanner.symbol = END;
	scanner.indent_level = 0;
	scanner.ignore_block = 0;
	scanner.line = scanner.doc_line = 0;
}

/** Singleton; reads from `stdin` until done; it doesn't make sense to call
 this twice since the input is consumed.
 @return Success.
 @throws[malloc, fread]
 @throws[EILSEQ] File has embedded nulls. */
int Scanner(void) {
	const size_t granularity = 1024;
	char *read_here, *zero;
	size_t nread, zero_len;
	/* Read all contents from `stdin` at once. */
	do {
		if(!(read_here = CharArrayBuffer(&scanner.buffer, granularity))
			|| (nread = fread(read_here, 1, granularity, stdin), ferror(stdin))
			|| !CharArrayAddSize(&scanner.buffer, nread)) goto catch;
	} while(nread == granularity);
	/* Embed '\0' on the end for simple lexing. */
	if(!(zero = CharArrayNew(&scanner.buffer))) goto catch;
	*zero = '\0';
	scanner.state = yyccode;
	/* Point these toward the first char; `buffer` is necessarily done
	 growing, or we could not do this. */
	scanner.marker = scanner.ctx_marker = scanner.from = scanner.cursor
		= CharArrayGet(&scanner.buffer);
	scanner.line = scanner.doc_line = 1;
	/* We use simplified sentinel method of detecting EOF, so the file can have
	 no embedded '\0'. */
	{
		const char *const buffer = CharArrayGet(&scanner.buffer);
		zero_len = (size_t)(strchr(buffer, '\0') - buffer);
		if(zero_len != CharArraySize(&scanner.buffer) - 1)
			{ errno = EILSEQ; fprintf(stderr,
			"Expects Modified UTF-8 encoding; embedded '\\0' at byte %lu/%lu."
			"\n", (unsigned long)zero_len,
			(unsigned long)CharArraySize(&scanner.buffer) - 1); goto catch; }
	}
	/* Scans all. */
	errno = 0;
	while((scanner.symbol = scan()))
		ReportPlace(), printf("Scanner: %s.\n", pos());
	if(errno) goto catch;
	return 1;
catch:
	Scanner_();
	return 0;
}

enum Symbol ScannerSymbol(void) { return scanner.symbol; }
const char *ScannerFrom(void) { return scanner.from; }
const char *ScannerTo(void) { return scanner.cursor; }
size_t ScannerLine(void) { return scanner.line; }
int ScannerIndentLevel(void) { return scanner.indent_level; }
